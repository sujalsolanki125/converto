/**
 * Export Handler
 * Handles export to DOCX, HTML, and PDF formats with formatting preservation
 */

class ExportHandler {
    constructor() {
        this.converter = new MarkdownConverter();
    }

    /**
     * Export to HTML with full styling
     */
    async exportToHTML(content, options = {}) {
        try {
            const {
                includeStyles = true,
                includeTOC = false,
                title = 'Document',
                author = '',
                date = new Date().toLocaleDateString()
            } = options;

            // Convert markdown to HTML
            const bodyHTML = this.converter.convert(content);

            // Build complete HTML document
            let html = '<!DOCTYPE html>\n';
            html += '<html lang="en">\n<head>\n';
            html += '  <meta charset="UTF-8">\n';
            html += '  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n';
            html += `  <title>${title}</title>\n`;

            if (includeStyles) {
                html += this.getEmbeddedStyles();
            }

            html += '</head>\n<body>\n';

            // Add header with metadata
            html += '<div class="document-header">\n';
            html += `  <h1 class="document-title">${title}</h1>\n`;
            if (author) html += `  <p class="document-author">By ${author}</p>\n`;
            html += `  <p class="document-date">${date}</p>\n`;
            html += '</div>\n';

            // Add TOC if requested
            if (includeTOC) {
                html += this.converter.generateTOCHTML(content);
            }

            // Add main content
            html += '<div class="document-content">\n';
            html += bodyHTML;
            html += '</div>\n';

            // Add footer
            html += '<div class="document-footer">\n';
            html += `  <p>Generated by Converto on ${date}</p>\n`;
            html += '</div>\n';

            html += '</body>\n</html>';

            // Create and download file
            const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
            saveAs(blob, `${this.sanitizeFilename(title)}.html`);

            return { success: true, message: 'HTML exported successfully' };
        } catch (error) {
            console.error('HTML export error:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Export to DOCX with formatting (Browser-compatible true .docx)
     */
    async exportToDOCX(content, options = {}) {
        try {
            const {
                title = 'Document',
                author = '',
                date = new Date().toLocaleDateString(),
                includeTOC = false,
                pageNumbers = true,
                theme = 'bw'  // Default to black & white for maximum compatibility
            } = options;

            // Convert markdown to HTML
            const bodyHTML = this.converter.convert(content);

            // Create Office Open XML structure for DOCX
            const docXml = this.createDocxXml(title, author, date, bodyHTML, theme);
            
            // Create DOCX using JSZip
            const zip = new JSZip();
            
            // Add the required DOCX structure in correct order
            zip.file('[Content_Types].xml', this.getDocxContentTypes());
            zip.file('_rels/.rels', this.getDocxRels());
            zip.file('docProps/app.xml', this.getDocxAppProps());
            zip.file('docProps/core.xml', this.getDocxCoreProps(title, author));
            zip.file('word/_rels/document.xml.rels', this.getDocxDocumentRels());
            zip.file('word/document.xml', docXml);
            zip.file('word/styles.xml', this.getDocxStyles(theme));
            zip.file('word/fontTable.xml', this.getDocxFontTable());
            zip.file('word/settings.xml', this.getDocxSettings());
            
            // Generate the DOCX blob with correct MIME type
            const blob = await zip.generateAsync({ 
                type: 'blob',
                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                compression: 'STORE',  // Use STORE (no compression) for better compatibility
                compressionOptions: {
                    level: 0
                }
            });
            saveAs(blob, `${this.sanitizeFilename(title)}.docx`);

            return { success: true, message: 'DOCX exported successfully' };
        } catch (error) {
            console.error('DOCX export error:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Create main document.xml content
     */
    createDocxXml(title, author, date, html, theme = 'bw') {
        // Convert HTML to Word XML format
        const wordContent = this.htmlToWordXml(html, theme);
        
        // Theme-aware date color
        const dateColor = theme === 'bw' ? '000000' : '808080';
        
        return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" 
            xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
            xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
            xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
            xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml">
    <w:body>
        <w:p>
            <w:pPr><w:pStyle w:val="Title"/></w:pPr>
            <w:r><w:t>${this.escapeXml(title)}</w:t></w:r>
        </w:p>
        ${author ? `<w:p>
            <w:pPr><w:pStyle w:val="Subtitle"/></w:pPr>
            <w:r><w:rPr><w:i/></w:rPr><w:t>By ${this.escapeXml(author)}</w:t></w:r>
        </w:p>` : ''}
        <w:p>
            <w:pPr><w:jc w:val="center"/></w:pPr>
            <w:r><w:rPr><w:sz w:val="20"/><w:color w:val="${dateColor}"/></w:rPr><w:t>${this.escapeXml(date)}</w:t></w:r>
        </w:p>
        ${wordContent}
        <w:sectPr>
            <w:pgSz w:w="12240" w:h="15840"/>
            <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440" w:header="720" w:footer="720" w:gutter="0"/>
            <w:cols w:space="720"/>
        </w:sectPr>
    </w:body>
</w:document>`;
    }

    /**
     * Convert HTML to Word XML paragraphs
     */
    htmlToWordXml(html, theme = 'bw') {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        let wordXml = '';
        
        const processNode = (node) => {
            if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent.trim();
                if (text) {
                    return `<w:r><w:t xml:space="preserve">${this.escapeXml(text)}</w:t></w:r>`;
                }
                return '';
            }
            
            if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                
                switch (tagName) {
                    case 'h1': {
                        const content = this.processChildren(node) || '<w:r><w:t></w:t></w:r>';
                        return `<w:p><w:pPr><w:pStyle w:val="Heading1"/></w:pPr>${content}</w:p>`;
                    }
                    case 'h2': {
                        const content = this.processChildren(node) || '<w:r><w:t></w:t></w:r>';
                        return `<w:p><w:pPr><w:pStyle w:val="Heading2"/></w:pPr>${content}</w:p>`;
                    }
                    case 'h3': {
                        const content = this.processChildren(node) || '<w:r><w:t></w:t></w:r>';
                        return `<w:p><w:pPr><w:pStyle w:val="Heading3"/></w:pPr>${content}</w:p>`;
                    }
                    case 'h4': {
                        const content = this.processChildren(node) || '<w:r><w:t></w:t></w:r>';
                        return `<w:p><w:pPr><w:pStyle w:val="Heading4"/></w:pPr>${content}</w:p>`;
                    }
                    case 'p': {
                        const content = this.processChildren(node) || '<w:r><w:t></w:t></w:r>';
                        return `<w:p>${content}</w:p>`;
                    }
                    case 'strong':
                    case 'b':
                        return `<w:r><w:rPr><w:b/></w:rPr><w:t xml:space="preserve">${this.escapeXml(node.textContent)}</w:t></w:r>`;
                    case 'em':
                    case 'i':
                        return `<w:r><w:rPr><w:i/></w:rPr><w:t xml:space="preserve">${this.escapeXml(node.textContent)}</w:t></w:r>`;
                    case 'code':
                        if (node.parentElement && node.parentElement.tagName.toLowerCase() === 'pre') {
                            return ''; // Handled by pre
                        }
                        return `<w:r><w:rPr><w:rFonts w:ascii="Consolas" w:hAnsi="Consolas"/><w:shd w:fill="F2F2F2"/></w:rPr><w:t xml:space="preserve">${this.escapeXml(node.textContent)}</w:t></w:r>`;
                    case 'pre':
                        const codeText = node.textContent;
                        return `<w:p><w:pPr><w:pStyle w:val="CodeBlock"/></w:pPr><w:r><w:rPr><w:rFonts w:ascii="Consolas" w:hAnsi="Consolas"/><w:color w:val="000000"/></w:rPr><w:t xml:space="preserve">${this.escapeXml(codeText)}</w:t></w:r></w:p>`;
                    case 'ul':
                    case 'ol':
                        return this.processListItems(node, tagName === 'ol');
                    case 'blockquote': {
                        const content = this.processChildren(node) || '<w:r><w:t></w:t></w:r>';
                        return `<w:p><w:pPr><w:pStyle w:val="Quote"/></w:pPr>${content}</w:p>`;
                    }
                    case 'table':
                        return this.processTable(node);
                    case 'br':
                        return '<w:r><w:br/></w:r>';
                    default:
                        return this.processChildren(node);
                }
            }
            return '';
        };
        
        Array.from(doc.body.childNodes).forEach(node => {
            wordXml += processNode(node);
        });
        
        return wordXml;
    }

    /**
     * Process child nodes
     */
    processChildren(node) {
        let result = '';
        Array.from(node.childNodes).forEach(child => {
            if (child.nodeType === Node.TEXT_NODE) {
                const text = child.textContent;
                if (text) {
                    result += `<w:r><w:t xml:space="preserve">${this.escapeXml(text)}</w:t></w:r>`;
                }
            } else if (child.nodeType === Node.ELEMENT_NODE) {
                const tagName = child.tagName.toLowerCase();
                const text = child.textContent;
                if (tagName === 'strong' || tagName === 'b') {
                    result += `<w:r><w:rPr><w:b/></w:rPr><w:t xml:space="preserve">${this.escapeXml(text)}</w:t></w:r>`;
                } else if (tagName === 'em' || tagName === 'i') {
                    result += `<w:r><w:rPr><w:i/></w:rPr><w:t xml:space="preserve">${this.escapeXml(text)}</w:t></w:r>`;
                } else if (tagName === 'code') {
                    result += `<w:r><w:rPr><w:rFonts w:ascii="Consolas" w:hAnsi="Consolas"/><w:shd w:fill="F2F2F2"/></w:rPr><w:t xml:space="preserve">${this.escapeXml(text)}</w:t></w:r>`;
                } else if (tagName === 'a') {
                    result += `<w:r><w:rPr><w:color w:val="0000FF"/><w:u w:val="single"/></w:rPr><w:t xml:space="preserve">${this.escapeXml(text)}</w:t></w:r>`;
                } else {
                    result += `<w:r><w:t xml:space="preserve">${this.escapeXml(text)}</w:t></w:r>`;
                }
            }
        });
        return result;
    }

    /**
     * Process list items
     */
    processListItems(listNode, isOrdered) {
        let result = '';
        const items = listNode.querySelectorAll(':scope > li');
        items.forEach((li, index) => {
            const text = li.textContent.trim() || '';
            result += `<w:p><w:pPr><w:pStyle w:val="${isOrdered ? 'ListNumber' : 'ListBullet'}"/></w:pPr><w:r><w:t xml:space="preserve">${this.escapeXml(text)}</w:t></w:r></w:p>`;
        });
        return result;
    }

    /**
     * Process table
     */
    processTable(tableNode) {
        let result = '<w:tbl><w:tblPr><w:tblStyle w:val="TableGrid"/><w:tblW w:w="5000" w:type="pct"/></w:tblPr>';
        
        const rows = tableNode.querySelectorAll('tr');
        rows.forEach((row, rowIndex) => {
            result += '<w:tr>';
            const cells = row.querySelectorAll('th, td');
            cells.forEach(cell => {
                const isHeader = cell.tagName.toLowerCase() === 'th';
                const text = cell.textContent.trim() || '';
                result += '<w:tc><w:tcPr>';
                if (isHeader) {
                    result += '<w:shd w:fill="F0F0F0"/>';
                }
                result += '</w:tcPr><w:p><w:r>';
                if (isHeader) {
                    result += '<w:rPr><w:b/></w:rPr>';
                }
                result += `<w:t xml:space="preserve">${this.escapeXml(text)}</w:t></w:r></w:p></w:tc>`;
            });
            result += '</w:tr>';
        });
        
        result += '</w:tbl>';
        return result;
    }

    /**
     * Get DOCX relationships file
     */
    getDocxRels() {
        return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
    <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
    <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
</Relationships>`;
    }

    /**
     * Get DOCX core properties
     */
    getDocxCoreProps(title, author) {
        return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" 
                   xmlns:dc="http://purl.org/dc/elements/1.1/" 
                   xmlns:dcterms="http://purl.org/dc/terms/" 
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <dc:title>${this.escapeXml(title)}</dc:title>
    <dc:creator>${this.escapeXml(author || 'Converto')}</dc:creator>
    <cp:lastModifiedBy>${this.escapeXml(author || 'Converto')}</cp:lastModifiedBy>
    <dcterms:created xsi:type="dcterms:W3CDTF">${new Date().toISOString()}</dcterms:created>
    <dcterms:modified xsi:type="dcterms:W3CDTF">${new Date().toISOString()}</dcterms:modified>
</cp:coreProperties>`;
    }

    /**
     * Get DOCX app properties
     */
    getDocxAppProps() {
        return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties">
    <Application>Converto</Application>
    <AppVersion>1.0</AppVersion>
</Properties>`;
    }

    /**
     * Get DOCX content types
     */
    getDocxContentTypes() {
        return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
    <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
    <Override PartName="/word/fontTable.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"/>
    <Override PartName="/word/settings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/>
    <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
    <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>
</Types>`;
    }

    /**
     * Get DOCX document relationships
     */
    getDocxDocumentRels() {
        return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
    <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable" Target="fontTable.xml"/>
    <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings" Target="settings.xml"/>
</Relationships>`;
    }

    /**
     * Get DOCX styles
     */
    getDocxStyles(theme = 'bw') {
        // Theme-specific colors
        const colors = theme === 'bw' ? {
            title: '000000',
            subtitle: '000000',
            heading1: '000000',
            heading2: '000000',
            heading3: '000000',
            heading4: '000000',
            normal: '000000',
            quote: '404040',
            codeBg: 'F5F5F5',
            codeText: '000000'
        } : {
            title: '2E74B5',
            subtitle: '595959',
            heading1: '2E74B5',
            heading2: '2E74B5',
            heading3: '1F4D78',
            heading4: '2E74B5',
            normal: '000000',
            quote: '595959',
            codeBg: 'F2F2F2',
            codeText: '000000'
        };
        
        return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" 
          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
    <w:docDefaults>
        <w:rPrDefault>
            <w:rPr>
                <w:rFonts w:ascii="Calibri" w:hAnsi="Calibri" w:eastAsia="Calibri" w:cs="Times New Roman"/>
                <w:sz w:val="22"/>
                <w:szCs w:val="22"/>
                <w:lang w:val="en-US" w:eastAsia="en-US" w:bidi="ar-SA"/>
            </w:rPr>
        </w:rPrDefault>
        <w:pPrDefault>
            <w:pPr>
                <w:spacing w:after="160" w:line="259" w:lineRule="auto"/>
            </w:pPr>
        </w:pPrDefault>
    </w:docDefaults>
    <w:style w:type="paragraph" w:default="1" w:styleId="Normal">
        <w:name w:val="Normal"/>
        <w:qFormat/>
        <w:pPr>
            <w:spacing w:after="160" w:line="259" w:lineRule="auto"/>
        </w:pPr>
        <w:rPr>
            <w:rFonts w:ascii="Calibri" w:hAnsi="Calibri"/>
            <w:sz w:val="22"/>
            <w:color w:val="000000"/>
        </w:rPr>
    </w:style>
    <w:style w:type="character" w:default="1" w:styleId="DefaultParagraphFont">
        <w:name w:val="Default Paragraph Font"/>
        <w:uiPriority w:val="1"/>
        <w:semiHidden/>
        <w:unhideWhenUsed/>
    </w:style>
    <w:style w:type="table" w:default="1" w:styleId="TableNormal">
        <w:name w:val="Normal Table"/>
        <w:uiPriority w:val="99"/>
        <w:semiHidden/>
        <w:unhideWhenUsed/>
        <w:tblPr>
            <w:tblInd w:w="0" w:type="dxa"/>
            <w:tblCellMar>
                <w:top w:w="0" w:type="dxa"/>
                <w:left w:w="108" w:type="dxa"/>
                <w:bottom w:w="0" w:type="dxa"/>
                <w:right w:w="108" w:type="dxa"/>
            </w:tblCellMar>
        </w:tblPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Title">
        <w:name w:val="Title"/>
        <w:basedOn w:val="Normal"/>
        <w:qFormat/>
        <w:pPr>
            <w:spacing w:before="240" w:after="200"/>
            <w:jc w:val="center"/>
        </w:pPr>
        <w:rPr>
            <w:b/>
            <w:sz w:val="56"/>
            <w:color w:val="${colors.title}"/>
        </w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Subtitle">
        <w:name w:val="Subtitle"/>
        <w:basedOn w:val="Normal"/>
        <w:qFormat/>
        <w:pPr>
            <w:spacing w:after="120"/>
            <w:jc w:val="center"/>
        </w:pPr>
        <w:rPr>
            <w:i/>
            <w:sz w:val="28"/>
            <w:color w:val="${colors.subtitle}"/>
        </w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Heading1">
        <w:name w:val="Heading 1"/>
        <w:basedOn w:val="Normal"/>
        <w:next w:val="Normal"/>
        <w:qFormat/>
        <w:pPr>
            <w:keepNext/>
            <w:spacing w:before="480" w:after="240"/>
        </w:pPr>
        <w:rPr>
            <w:b/>
            <w:sz w:val="36"/>
            <w:color w:val="${colors.heading1}"/>
        </w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Heading2">
        <w:name w:val="Heading 2"/>
        <w:basedOn w:val="Normal"/>
        <w:next w:val="Normal"/>
        <w:qFormat/>
        <w:pPr>
            <w:keepNext/>
            <w:spacing w:before="320" w:after="160"/>
        </w:pPr>
        <w:rPr>
            <w:b/>
            <w:sz w:val="28"/>
            <w:color w:val="${colors.heading2}"/>
        </w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Heading3">
        <w:name w:val="Heading 3"/>
        <w:basedOn w:val="Normal"/>
        <w:next w:val="Normal"/>
        <w:qFormat/>
        <w:pPr>
            <w:keepNext/>
            <w:spacing w:before="240" w:after="120"/>
        </w:pPr>
        <w:rPr>
            <w:b/>
            <w:sz w:val="24"/>
            <w:color w:val="${colors.heading3}"/>
        </w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Heading4">
        <w:name w:val="Heading 4"/>
        <w:basedOn w:val="Normal"/>
        <w:next w:val="Normal"/>
        <w:qFormat/>
        <w:pPr>
            <w:keepNext/>
            <w:spacing w:before="160" w:after="80"/>
        </w:pPr>
        <w:rPr>
            <w:b/>
            <w:i/>
            <w:sz w:val="22"/>
            <w:color w:val="${colors.heading4}"/>
        </w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="CodeBlock">
        <w:name w:val="Code Block"/>
        <w:basedOn w:val="Normal"/>
        <w:pPr>
            <w:spacing w:before="200" w:after="200"/>
            <w:shd w:fill="${colors.codeBg}"/>
        </w:pPr>
        <w:rPr>
            <w:rFonts w:ascii="Consolas" w:hAnsi="Consolas"/>
            <w:sz w:val="20"/>
            <w:color w:val="${colors.codeText}"/>
        </w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Quote">
        <w:name w:val="Quote"/>
        <w:basedOn w:val="Normal"/>
        <w:pPr>
            <w:ind w:left="720"/>
            <w:spacing w:before="200" w:after="200"/>
        </w:pPr>
        <w:rPr>
            <w:i/>
            <w:color w:val="${colors.quote}"/>
        </w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="ListBullet">
        <w:name w:val="List Bullet"/>
        <w:basedOn w:val="Normal"/>
        <w:pPr>
            <w:ind w:left="720"/>
        </w:pPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="ListNumber">
        <w:name w:val="List Number"/>
        <w:basedOn w:val="Normal"/>
        <w:pPr>
            <w:ind w:left="720"/>
        </w:pPr>
    </w:style>
    <w:style w:type="table" w:styleId="TableGrid">
        <w:name w:val="Table Grid"/>
        <w:basedOn w:val="TableNormal"/>
        <w:uiPriority w:val="39"/>
        <w:tblPr>
            <w:tblBorders>
                <w:top w:val="single" w:sz="4" w:space="0" w:color="BFBFBF"/>
                <w:left w:val="single" w:sz="4" w:space="0" w:color="BFBFBF"/>
                <w:bottom w:val="single" w:sz="4" w:space="0" w:color="BFBFBF"/>
                <w:right w:val="single" w:sz="4" w:space="0" w:color="BFBFBF"/>
                <w:insideH w:val="single" w:sz="4" w:space="0" w:color="BFBFBF"/>
                <w:insideV w:val="single" w:sz="4" w:space="0" w:color="BFBFBF"/>
            </w:tblBorders>
        </w:tblPr>
    </w:style>
</w:styles>`;
    }

    /**
     * Escape XML special characters
     */
    escapeXml(text) {
        if (!text) return '';
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    }

    /**
     * Get DOCX font table
     */
    getDocxFontTable() {
        return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:fonts xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" 
         xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
    <w:font w:name="Calibri">
        <w:panose1 w:val="020F0502020204030204"/>
        <w:charset w:val="00"/>
        <w:family w:val="swiss"/>
        <w:pitch w:val="variable"/>
    </w:font>
    <w:font w:name="Consolas">
        <w:panose1 w:val="020B0609020204030204"/>
        <w:charset w:val="00"/>
        <w:family w:val="modern"/>
        <w:pitch w:val="fixed"/>
    </w:font>
</w:fonts>`;
    }

    /**
     * Get DOCX settings
     */
    getDocxSettings() {
        return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:zoom w:percent="100"/>
    <w:defaultTabStop w:val="720"/>
    <w:characterSpacingControl w:val="doNotCompress"/>
    <w:compat>
        <w:compatSetting w:name="compatibilityMode" w:uri="http://schemas.microsoft.com/office/word" w:val="15"/>
    </w:compat>
</w:settings>`;
    }

    /**
     * OLD DOCX METHODS (DEPRECATED) - Kept for reference
     */
    async exportToDOCX_OLD_NODE_VERSION(content, options = {}) {
        try {
            const {
                title = 'Document',
                author = '',
                date = new Date().toLocaleDateString(),
                includeTOC = false,
                pageNumbers = true
            } = options;

            // Check if docx library is available
            if (typeof docx === 'undefined') {
                throw new Error('DOCX library not loaded. Please refresh the page.');
            }

            // Import docx library
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableCell, TableRow, WidthType, AlignmentType, BorderStyle } = docx;

            // Parse markdown to tokens
            const tokens = marked.lexer(content);
            
            // Build document sections
            const children = [];

            // Add title
            children.push(
                new Paragraph({
                    text: title,
                    heading: HeadingLevel.TITLE,
                    spacing: { after: 200 }
                })
            );

            // Add author and date
            if (author) {
                children.push(
                    new Paragraph({
                        children: [
                            new TextRun({
                                text: `By ${author}`,
                                italics: true
                            })
                        ],
                        spacing: { after: 100 }
                    })
                );
            }

            children.push(
                new Paragraph({
                    children: [
                        new TextRun({
                            text: date,
                            size: 20,
                            color: "666666"
                        })
                    ],
                    spacing: { after: 400 }
                })
            );

            // Process markdown tokens
            this.processTokensToDocx(tokens, children);

            // Create document
            const doc = new Document({
                sections: [{
                    properties: {
                        page: {
                            margin: {
                                top: 1440,  // 1 inch
                                right: 1440,
                                bottom: 1440,
                                left: 1440
                            }
                        }
                    },
                    children: children
                }]
            });

            // Generate and download
            const blob = await Packer.toBlob(doc);
            saveAs(blob, `${this.sanitizeFilename(title)}.docx`);

            return { success: true, message: 'DOCX exported successfully' };
        } catch (error) {
            console.error('DOCX export error:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Process markdown tokens and convert to docx elements
     */
    processTokensToDocx(tokens, children) {
        for (const token of tokens) {
            switch (token.type) {
                case 'heading':
                    children.push(this.createHeading(token));
                    break;
                case 'paragraph':
                    children.push(this.createParagraph(token));
                    break;
                case 'code':
                    children.push(this.createCodeBlock(token));
                    break;
                case 'table':
                    children.push(this.createTable(token));
                    break;
                case 'list':
                    this.createList(token, children);
                    break;
                case 'blockquote':
                    children.push(this.createBlockquote(token));
                    break;
                case 'space':
                    // Skip spaces
                    break;
                default:
                    // Handle other types as paragraphs
                    if (token.text) {
                        children.push(new Paragraph({ text: token.text }));
                    }
            }
        }
    }

    /**
     * Create heading from token
     */
    createHeading(token) {
        const { Paragraph, HeadingLevel } = docx;
        
        const headingLevels = {
            1: HeadingLevel.HEADING_1,
            2: HeadingLevel.HEADING_2,
            3: HeadingLevel.HEADING_3,
            4: HeadingLevel.HEADING_4,
            5: HeadingLevel.HEADING_5,
            6: HeadingLevel.HEADING_6
        };

        return new Paragraph({
            text: this.stripHTML(token.text),
            heading: headingLevels[token.depth] || HeadingLevel.HEADING_1,
            spacing: { before: 240, after: 120 }
        });
    }

    /**
     * Create paragraph from token
     */
    createParagraph(token) {
        const { Paragraph } = docx;
        const textRuns = this.parseInlineFormatting(token.text);
        
        return new Paragraph({
            children: textRuns,
            spacing: { after: 200 }
        });
    }

    /**
     * Parse inline formatting (bold, italic, code, etc.)
     */
    parseInlineFormatting(text) {
        const { TextRun } = docx;
        const runs = [];
        
        // Simple implementation - strip HTML and create plain text
        // For production, you'd want proper HTML parsing
        const cleanText = this.stripHTML(text);
        
        // Check for code spans
        const codeRegex = /`([^`]+)`/g;
        let lastIndex = 0;
        let match;
        
        while ((match = codeRegex.exec(cleanText)) !== null) {
            // Add text before code
            if (match.index > lastIndex) {
                runs.push(new TextRun(cleanText.substring(lastIndex, match.index)));
            }
            
            // Add code
            runs.push(new TextRun({
                text: match[1],
                font: "Consolas",
                size: 20,
                shading: {
                    fill: "F5F5F5"
                }
            }));
            
            lastIndex = match.index + match[0].length;
        }
        
        // Add remaining text
        if (lastIndex < cleanText.length) {
            runs.push(new TextRun(cleanText.substring(lastIndex)));
        }
        
        return runs.length > 0 ? runs : [new TextRun(cleanText)];
    }

    /**
     * Create code block
     */
    createCodeBlock(token) {
        const { Paragraph, TextRun, BorderStyle } = docx;
        
        return new Paragraph({
            children: [
                new TextRun({
                    text: token.text,
                    font: "Consolas",
                    size: 20
                })
            ],
            shading: {
                fill: "1e293b"
            },
            spacing: { before: 200, after: 200 },
            border: {
                top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }
            }
        });
    }

    /**
     * Create table
     */
    createTable(token) {
        const { Table, TableRow, TableCell, Paragraph, WidthType } = docx;
        
        const rows = [];
        
        // Header row
        if (token.header && token.header.length > 0) {
            const headerCells = token.header.map(cell => 
                new TableCell({
                    children: [new Paragraph(this.stripHTML(cell.text))],
                    shading: { fill: "4A90E2" }
                })
            );
            rows.push(new TableRow({ children: headerCells }));
        }
        
        // Body rows
        if (token.rows) {
            for (const row of token.rows) {
                const cells = row.map(cell =>
                    new TableCell({
                        children: [new Paragraph(this.stripHTML(cell.text))]
                    })
                );
                rows.push(new TableRow({ children: cells }));
            }
        }
        
        return new Table({
            rows: rows,
            width: { size: 100, type: WidthType.PERCENTAGE }
        });
    }

    /**
     * Create list
     */
    createList(token, children) {
        const { Paragraph } = docx;
        
        for (const item of token.items) {
            children.push(
                new Paragraph({
                    text: this.stripHTML(item.text),
                    bullet: { level: 0 },
                    spacing: { after: 100 }
                })
            );
        }
    }

    /**
     * Create blockquote
     */
    createBlockquote(token) {
        const { Paragraph, TextRun, BorderStyle } = docx;
        
        // Extract text from nested tokens
        let text = '';
        if (token.tokens) {
            for (const t of token.tokens) {
                if (t.text) {
                    text += this.stripHTML(t.text) + ' ';
                }
            }
        }
        
        return new Paragraph({
            children: [
                new TextRun({
                    text: text.trim(),
                    italics: true,
                    color: "666666"
                })
            ],
            indent: { left: 720 },
            spacing: { before: 200, after: 200 },
            border: {
                left: { style: BorderStyle.SINGLE, size: 12, color: "d946ef" }
            }
        });
    }

    /**
     * Strip HTML tags from text
     */
    stripHTML(html) {
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        return tmp.textContent || tmp.innerText || '';
    }

    /**
     * OLD HTML-BASED DOCX METHOD (DEPRECATED)
     */
    async exportToDOCX_OLD(content, options = {}) {
        try {
            const {
                title = 'Document',
                author = '',
                date = new Date().toLocaleDateString(),
                includeTOC = false,
                pageNumbers = true
            } = options;

            // Convert markdown to HTML first
            const html = this.converter.convert(content);
            
            // Create a rich HTML document for Word
            let docHTML = `
<!DOCTYPE html>
<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
<head>
    <meta charset='utf-8'>
    <title>${title}</title>
    <!--[if gte mso 9]>
    <xml>
        <w:WordDocument>
            <w:View>Print</w:View>
            <w:Zoom>100</w:Zoom>
            <w:DoNotOptimizeForBrowser/>
        </w:WordDocument>
    </xml>
    <![endif]-->
    <style>
        @page {
            size: 8.5in 11in;
            margin: 0.75in 1in 1in 1in;
        }
        body {
            font-family: 'Segoe UI', 'Calibri', 'Arial', sans-serif;
            font-size: 11pt;
            line-height: 1.6;
            color: #ffffff;
            background-color: #0f172a;
            margin: 0;
            padding: 0;
        }
        h1 {
            font-size: 24pt;
            font-weight: bold;
            color: #66e4ff;
            margin-top: 12pt;
            margin-bottom: 12pt;
            page-break-after: avoid;
            page-break-inside: avoid;
            border-bottom: 2px solid #66e4ff;
            padding-bottom: 6pt;
        }
        h2 {
            font-size: 18pt;
            font-weight: bold;
            color: #d946ef;
            margin-top: 12pt;
            margin-bottom: 6pt;
            page-break-after: avoid;
            page-break-inside: avoid;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 4pt;
        }
        h3 {
            font-size: 14pt;
            font-weight: bold;
            color: #66e4ff;
            margin-top: 10pt;
            margin-bottom: 4pt;
            page-break-after: avoid;
            page-break-inside: avoid;
        }
        h4 {
            font-size: 12pt;
            font-weight: bold;
            color: #ffffff;
            margin-top: 8pt;
            margin-bottom: 4pt;
            page-break-after: avoid;
        }
        p {
            margin: 0 0 10pt 0;
        }
        strong {
            font-weight: bold;
            color: #66e4ff;
        }
        em {
            font-style: italic;
            color: #d946ef;
        }
        code {
            font-family: 'Consolas', 'Courier New', monospace;
            background-color: rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
            padding: 2px 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            font-size: 10pt;
        }
        pre {
            font-family: 'Consolas', 'Courier New', monospace;
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 12pt;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            margin: 10pt 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 10pt;
            page-break-inside: avoid;
            line-height: 1.4;
        }
        pre code {
            background: transparent;
            border: none;
            padding: 0;
            color: inherit;
            font-size: 10pt;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 12pt 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            page-break-inside: avoid;
            background-color: rgba(255, 255, 255, 0.02);
        }
        th {
            background-color: rgba(102, 228, 255, 0.1);
            color: #66e4ff;
            font-weight: bold;
            padding: 8pt;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: left;
        }
        td {
            padding: 6pt 8pt;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
        }
        tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
        }
        ul, ol {
            margin: 6pt 0 10pt 0;
            padding-left: 20pt;
        }
        li {
            margin: 4pt 0;
            line-height: 1.5;
        }
        blockquote {
            border-left: 4px solid #d946ef;
            padding-left: 12pt;
            margin: 10pt 0 10pt 10pt;
            color: #94a3b8;
            font-style: italic;
            background-color: rgba(255, 255, 255, 0.02);
            padding: 8pt;
            border-radius: 0 4px 4px 0;
            page-break-inside: avoid;
        }
        .highlight-yellow {
            background-color: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .highlight-green {
            background-color: rgba(16, 185, 129, 0.2);
            color: #10b981;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .highlight-blue {
            background-color: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .highlight-pink {
            background-color: rgba(236, 72, 153, 0.2);
            color: #f472b6;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .document-title {
            text-align: center;
            font-size: 24pt;
            font-weight: bold;
            color: #66e4ff;
            margin: 0 0 4pt 0;
            padding: 0;
            text-shadow: 0 0 10px rgba(102, 228, 255, 0.3);
        }
        .document-author {
            text-align: center;
            font-style: italic;
            margin: 0;
            padding: 0;
            font-size: 11pt;
            color: #94a3b8;
        }
        .document-date {
            text-align: center;
            color: #64748b;
            margin: 0 0 12pt 0;
            padding: 0;
            font-size: 10pt;
        }
        .page-break {
            page-break-before: always;
        }
        .keep-together {
            page-break-inside: avoid;
        }
        .math-equation {
            font-family: 'Cambria Math', 'Times New Roman', serif;
            font-style: italic;
            margin: 8pt 0;
            color: #e2e8f0;
        }
        .math-display {
            text-align: center;
            margin: 12pt 0;
            font-size: 13pt;
            color: #e2e8f0;
        }
        a {
            color: #66e4ff;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="document-title">${title}</div>
    ${author ? `<div class="document-author">By ${author}</div>` : ''}
    <div class="document-date">${date}</div>
    
    ${html}
    
    <div style="margin-top: 24pt; padding-top: 8pt; border-top: 1px solid rgba(255, 255, 255, 0.1); text-align: center; color: #64748b; font-size: 9pt;">
        Generated by Converto on ${date}
    </div>
</body>
</html>`;

            // Create blob with proper MIME type for Word
            const blob = new Blob(['\ufeff', docHTML], {
                type: 'application/msword;charset=utf-8'
            });
            
            saveAs(blob, `${this.sanitizeFilename(title)}.doc`);

            return { success: true, message: 'DOCX exported successfully' };
        } catch (error) {
            console.error('DOCX export error:', error);
            return { success: false, error: error.message };
        }
    }



    /**
     * Export to PDF with optimized settings
     */
    async exportToPDF(content, options = {}) {
        try {
            const {
                title = 'Document',
                author = '',
                date = new Date().toLocaleDateString(),
                theme = 'color'
            } = options;

            // Define theme colors
            const colors = theme === 'bw' ? {
                background: '#ffffff',
                text: '#000000',
                headingPrimary: '#000000',
                headingSecondary: '#000000',
                codeBackground: '#f5f5f5',
                codeText: '#000000',
                codeBorder: '#cccccc',
                tableBorder: '#cccccc',
                tableHeader: '#f5f5f5',
                tableHeaderText: '#000000',
                tableText: '#000000',
                blockquoteBorder: '#cccccc',
                blockquoteText: '#666666',
                blockquoteBackground: '#f9f9f9',
                link: '#0000ff',
                border: '#cccccc',
                metaText: '#666666'
            } : {
                background: '#0f172a',
                text: '#ffffff',
                headingPrimary: '#66e4ff',
                headingSecondary: '#d946ef',
                codeBackground: '#1e293b',
                codeText: '#e2e8f0',
                codeBorder: 'rgba(255, 255, 255, 0.1)',
                tableBorder: 'rgba(255, 255, 255, 0.1)',
                tableHeader: 'rgba(102, 228, 255, 0.1)',
                tableHeaderText: '#66e4ff',
                tableText: '#e2e8f0',
                blockquoteBorder: '#d946ef',
                blockquoteText: '#94a3b8',
                blockquoteBackground: 'rgba(255, 255, 255, 0.02)',
                link: '#66e4ff',
                border: 'rgba(255, 255, 255, 0.1)',
                metaText: '#64748b'
            };

            // Convert markdown to HTML
            const bodyHTML = this.converter.convert(content);

            // Create container for PDF
            const element = document.createElement('div');
            element.style.cssText = `
                width: 100%;
                background: ${colors.background};
                font-family: 'Segoe UI', 'Calibri', 'Arial', sans-serif;
                font-size: 11pt;
                line-height: 1.6;
                color: ${colors.text};
                padding: 20px;
            `;

            // Build HTML structure
            element.innerHTML = `
                <div style="padding-bottom: 10px; margin-bottom: 20px; border-bottom: 2px solid ${colors.headingPrimary};">
                    <h1 style="margin: 0; font-size: 24pt; color: ${colors.headingPrimary}; text-align: center;">${title}</h1>
                    ${author ? `<p style="margin: 5px 0 0; color: ${colors.metaText}; font-size: 11pt; text-align: center;">By ${author}</p>` : ''}
                    <p style="margin: 0; font-size: 10pt; color: ${colors.metaText}; text-align: center;">${date}</p>
                </div>

                <div class="pdf-content">
                    ${bodyHTML}
                </div>

                <div style="margin-top: 30px; padding-top: 10px; border-top: 1px solid ${colors.border}; text-align: center; font-size: 9pt; color: ${colors.metaText};">
                    Page <span class="pageNumber"></span>
                </div>
            `;

            // Apply inline styles to content
            this.applyPDFStyles(element, colors);

            // Optimized PDF configuration
            const opt = {
                margin: [10, 10, 10, 10],
                filename: `${this.sanitizeFilename(title)}.pdf`,
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: { 
                    scale: 2, 
                    useCORS: true,
                    scrollY: 0,
                    backgroundColor: colors.background,
                    logging: false
                },
                jsPDF: { 
                    unit: 'mm', 
                    format: 'a4', 
                    orientation: 'portrait' 
                },
                pagebreak: { 
                    mode: ['avoid-all', 'css', 'legacy']
                }
            };

            // Generate PDF
            await html2pdf().set(opt).from(element).save();

            return { success: true, message: 'PDF exported successfully' };
        } catch (error) {
            console.error('PDF export error:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Apply PDF-specific styles to elements
     */
    applyPDFStyles(container, colors) {
        // Style headings
        const h1s = container.querySelectorAll('.pdf-content h1');
        h1s.forEach(h => h.style.cssText = `font-size: 20pt; color: ${colors.headingPrimary}; border-bottom: 1px solid ${colors.border}; padding-bottom: 5px; margin-top: 20px;`);

        const h2s = container.querySelectorAll('.pdf-content h2');
        h2s.forEach(h => h.style.cssText = `font-size: 16pt; color: ${colors.headingSecondary}; margin-top: 15px; margin-bottom: 8px; font-weight: 600;`);
        
        const h3s = container.querySelectorAll('.pdf-content h3');
        h3s.forEach(h => h.style.cssText = `font-size: 14pt; color: ${colors.headingPrimary}; margin-top: 12px; margin-bottom: 6px; font-weight: 600;`);

        // Code Blocks
        const codeBlocks = container.querySelectorAll('pre');
        codeBlocks.forEach(pre => {
            pre.style.cssText = `
                background: ${colors.codeBackground} !important; 
                color: ${colors.codeText} !important; 
                padding: 15px; 
                border-radius: 5px; 
                margin: 10px 0; 
                font-family: 'Consolas', monospace; 
                font-size: 9pt; 
                white-space: pre-wrap; 
                overflow-x: hidden; 
                page-break-inside: avoid;
                border: 1px solid ${colors.codeBorder};
            `;
            // Reset inner code styles so they inherit the text color
            const code = pre.querySelector('code');
            if (code) code.style.cssText = 'background: transparent !important; color: inherit !important; padding: 0;';
        });

        // Table Styling
        const tables = container.querySelectorAll('table');
        tables.forEach(table => {
            table.style.cssText = `width: 100%; border-collapse: collapse; margin: 15px 0; page-break-inside: avoid; font-size: 10pt; border: 1px solid ${colors.tableBorder}; background: ${colors.codeBackground};`;
            
            const ths = table.querySelectorAll('th');
            ths.forEach(th => {
                th.style.cssText = `background: ${colors.tableHeader}; color: ${colors.tableHeaderText}; padding: 8px; border: 1px solid ${colors.tableBorder}; text-align: left; font-weight: bold;`;
            });
            
            const tds = table.querySelectorAll('td');
            tds.forEach(td => {
                td.style.cssText = `padding: 8px; border: 1px solid ${colors.tableBorder}; color: ${colors.tableText};`;
            });
        });

        // Style Blockquotes
        const blockquotes = container.querySelectorAll('blockquote');
        blockquotes.forEach(bq => {
            bq.style.cssText = `border-left: 4px solid ${colors.blockquoteBorder}; padding-left: 15px; margin: 10px 0; color: ${colors.blockquoteText}; font-style: italic; background: ${colors.blockquoteBackground}; padding: 10px; border-radius: 0 4px 4px 0;`;
        });
        
        // Images
        const images = container.querySelectorAll('img');
        images.forEach(img => {
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
        });
        
        // Links
        const links = container.querySelectorAll('a');
        links.forEach(a => {
            a.style.color = colors.link;
            a.style.textDecoration = 'none';
        });

        // KaTeX Math Formulas - force black color for B&W theme
        const katexElements = container.querySelectorAll('.katex, .katex-display, .katex-html');
        katexElements.forEach(el => {
            el.style.color = colors.text;
        });

        // Force all KaTeX internal elements to use theme text color
        const katexInternals = container.querySelectorAll('.katex *');
        katexInternals.forEach(el => {
            el.style.color = `${colors.text} !important`;
        });
    }

    /**
     * Wait for all images to load
     */
    async waitForImages(container) {
        const images = Array.from(container.querySelectorAll('img'));
        if (images.length === 0) return;

        await Promise.all(images.map(img => {
            if (img.complete && img.naturalHeight > 0) {
                return Promise.resolve();
            }
            return new Promise(resolve => {
                const timeout = setTimeout(() => resolve(), 5000);
                img.onload = () => {
                    clearTimeout(timeout);
                    resolve();
                };
                img.onerror = () => {
                    clearTimeout(timeout);
                    resolve();
                };
            });
        }));
    }

    /**
     * Copy formatted content to clipboard
     */
    async copyFormattedContent(content) {
        try {
            const html = this.converter.convert(content);
            const plainText = this.converter.toPlainText(content);

            // Create clipboard data
            const clipboardItem = new ClipboardItem({
                'text/html': new Blob([html], { type: 'text/html' }),
                'text/plain': new Blob([plainText], { type: 'text/plain' })
            });

            await navigator.clipboard.write([clipboardItem]);

            return { success: true, message: 'Content copied to clipboard with formatting' };
        } catch (error) {
            // Fallback to plain text copy
            try {
                const plainText = this.converter.toPlainText(content);
                await navigator.clipboard.writeText(plainText);
                return { success: true, message: 'Content copied to clipboard (plain text)' };
            } catch (err) {
                console.error('Copy error:', err);
                return { success: false, error: err.message };
            }
        }
    }

    /**
     * Get embedded CSS styles for HTML export
     */
    getEmbeddedStyles() {
        return `
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 40px auto;
            padding: 20px;
            color: #ffffff;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        }
        .document-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #66e4ff;
        }
        .document-title {
            color: #66e4ff;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        .document-author {
            font-style: italic;
            color: #94a3b8;
        }
        .document-date {
            color: #64748b;
        }
        .document-content {
            background: rgba(255, 255, 255, 0.05);
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .document-footer {
            text-align: center;
            margin-top: 40px;
            color: #64748b;
            font-size: 0.9em;
        }
        code {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #e2e8f0;
        }
        pre {
            background-color: #1e293b;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        pre code {
            background: none;
            padding: 0;
            color: #abb2bf;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        th, td {
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: rgba(102, 228, 255, 0.1);
            color: #66e4ff;
            font-weight: 600;
        }
        tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
        }
        td {
            color: #e2e8f0;
        }
        .katex-display {
            margin: 1.5em 0;
        }
        .highlight-yellow { background-color: rgba(251, 191, 36, 0.2); color: #fbbf24; padding: 2px 4px; }
        .highlight-green { background-color: rgba(16, 185, 129, 0.2); color: #10b981; padding: 2px 4px; }
        .highlight-blue { background-color: rgba(59, 130, 246, 0.2); color: #60a5fa; padding: 2px 4px; }
        .highlight-pink { background-color: rgba(236, 72, 153, 0.2); color: #f472b6; padding: 2px 4px; }
        blockquote {
            border-left: 4px solid #d946ef;
            padding-left: 15px;
            margin: 10px 0;
            color: #94a3b8;
            font-style: italic;
            background: rgba(255, 255, 255, 0.02);
            padding: 10px;
            border-radius: 0 4px 4px 0;
        }
        a { color: #66e4ff; text-decoration: none; }
    </style>`;
    }

    /**
     * Apply inline styles to container for PDF export
     */
    applyInlineStyles(container) {
        // Style code blocks
        const codeBlocks = container.querySelectorAll('pre');
        codeBlocks.forEach(block => {
            block.style.backgroundColor = '#282c34';
            block.style.padding = '16px';
            block.style.borderRadius = '6px';
            block.style.overflow = 'auto';
        });

        // Style tables
        const tables = container.querySelectorAll('table');
        tables.forEach(table => {
            table.style.borderCollapse = 'collapse';
            table.style.width = '100%';
            table.style.margin = '20px 0';
        });

        const cells = container.querySelectorAll('th, td');
        cells.forEach(cell => {
            cell.style.border = '1px solid #e2e8f0';
            cell.style.padding = '12px';
        });

        const headers = container.querySelectorAll('th');
        headers.forEach(th => {
            th.style.backgroundColor = '#2563eb';
            th.style.color = 'white';
        });

        // Style math equations
        const mathDisplays = container.querySelectorAll('.katex-display');
        mathDisplays.forEach(math => {
            math.style.margin = '1.5em 0';
        });
    }

    /**
     * Sanitize filename
     */
    sanitizeFilename(filename) {
        return filename.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ExportHandler;
}
